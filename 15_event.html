<!-- Balloon -->

<!-- Write a page that displays a balloon (using the balloon emoji, ðŸŽˆ). When you -->
<!-- press the up arrow, it should inflate (grow) 10 percent, and when you press the -->
<!-- down arrow, it should deflate (shrink) 10 percent. -->

<!-- You can control the size of text (emoji are text) by setting the font-size CSS -->
<!-- property (style.fontSize) on its parent element. Remember to include a unit in -->
<!-- the valueâ€”for example, pixels (10px). -->

<!-- The key names of the arrow keys are "ArrowUp" and "ArrowDown". Make sure the -->
<!-- keys change only the balloon, without scrolling the page. -->

<!-- When that works, add a feature where, if you blow up the balloon past a certain -->
<!-- size, it explodes. In this case, exploding means that it is replaced with an ðŸ’¥ -->
<!-- emoji, and the event handler is removed (so that you canâ€™t inflate or deflate -->
<!-- the explosion). -->

<p>ðŸŽˆ</p>

<script>
 // Your code hereement. Remember to include a unit in the valueâ€”for example, pixels (10px).
 let balloon = document.querySelector("p");
 balloon.style.fontSize = "16px";
 let size = 16;
 function update(event) {
     if (event.key == "ArrowUp") {
	 let toAdd = Math.ceil(size * 0.1);
	 size += toAdd;
	 console.log(size);
	 if (size > 100) {
             balloon.textContent = "ðŸ’¥";
             window.removeEventListener("keydown", update);
	 }
	 balloon.style.fontSize = `${size}px`;
	 event.preventDefault();
     }
     if (event.key == "ArrowDown") {
	 let toSubtract = Math.ceil(size * 0.1);
	 size -= toSubtract;
	 balloon.style.fontSize = `${size}px`;
	 event.preventDefault();
     }
 }
 window.addEventListener("keydown", update)
</script>


<!-- Mouse trail -->

<!-- In JavaScriptâ€™s early days, which was the high time of gaudy home pages with -->
<!-- lots of animated images, people came up with some truly inspiring ways to use -->
<!-- the language. -->

<!-- One of these was the mouse trailâ€”a series of elements that would follow the -->
<!-- mouse pointer as you moved it across the page. -->

<!-- In this exercise, I want you to implement a mouse trail. Use absolutely -->
<!-- positioned <div> elements with a fixed size and background color (refer to the -->
<!-- code in the â€œMouse Clicksâ€ section for an example). Create a bunch of such -->
<!-- elements and, when the mouse moves, display them in the wake of the mouse -->
<!-- pointer. -->

<!-- There are various possible approaches here. You can make your solution as simple -->
<!-- or as complex as you want. A simple solution to start with is to keep a fixed -->
<!-- number of trail elements and cycle through them, moving the next one to the -->
<!-- mouseâ€™s current position every time a "mousemove" event occurs. -->
  
<style>
 .trail { /* className for the trail elements */
     position: absolute;
     height: 6px; width: 6px;
     border-radius: 3px;
     background: teal;
 }
 body {
     height: 300px;
 }
</style>

<script>
 // Your code here.
 for (let i = 0; i < 10; i++) {
     let div = document.createElement('div');
     div.className = 'trail';
     document.body.appendChild(div);
 }
 document.body.addEventListener('mousemove', (event) => {
     let trails = Array.from(document.querySelectorAll('.trail'));
     let differenceX = 10;
     let differenceY = 10;
     for (let trail of trails) {
	 trail.style.top = event.clientY + differenceY + 'px';
	 differenceY += 5;
	 trail.style.left = event.clientX + differenceX + 'px';
	 differenceX += 5;
     }
 });
</script>
  
<!-- Tabs -->

<!-- Tabbed panels are widely used in user interfaces. They allow you to select an -->
<!-- interface panel by choosing from a number of tabs â€œsticking outâ€ above an -->
<!-- element. -->

<!-- In this exercise you must implement a simple tabbed interface. Write a function, -->
<!-- asTabs, that takes a DOM node and creates a tabbed interface showing the child -->
<!-- elements of that node. It should insert a list of <button> elements at the top -->
<!-- of the node, one for each child element, containing text retrieved from the -->
<!-- data-tabname attribute of the child. All but one of the original children should -->
<!-- be hidden (given a display style of none). The currently visible node can be -->
<!-- selected by clicking the buttons. -->

<!-- When that works, extend it to style the button for the currently selected tab -->
<!-- differently so that it is obvious which tab is selected. -->

<tab-panel>
    <div data-tabname="one">Tab one</div>
    <div data-tabname="two">Tab two</div>
    <div data-tabname="three">Tab three</div>
</tab-panel>
<script>
 function asTabs(node) {
     // Your code here.
     let children = Array.from(node.children);
     // store objects with bidings buttons and associated tabs
     let buttonsAndTabs = [];
     for (let i = 0; i < children.length; i++) {
	 let button = document.createElement('button');
	 let text = document.createTextNode(children[i].getAttribute("data-tabname"));
	 button.appendChild(text);
	 document.body.insertBefore(button, node);
	 buttonsAndTabs.push( { button: button, tab: children[i] } );
     }
     // take a button, display associated tab
     function displayTab(button) {
	 for (let obj of buttonsAndTabs) {
             if (obj.button === button) {
		 obj.tab.style.display = ''; 
             } else {
		 obj.tab.style.display = 'none'; 
             }
	 }
     }
     let buttons = document.querySelectorAll('button');
     for (let i = 0; i< buttons.length; i++) {
         buttons[i].addEventListener('click', (event) => {
             displayTab(event.target);
         });
     }
     displayTab(buttons[0]);
 }
 asTabs(document.querySelector("tab-panel"));
</script>
